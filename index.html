<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nechadil.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Nechadil">
<meta property="og:url" content="https://nechadil.github.io/index.html">
<meta property="og:site_name" content="Nechadil">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nechadil">

<link rel="canonical" href="https://nechadil.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Nechadil</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Nechadil</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nechadil.github.io/2020/03/23/Docker cheat sheet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nechadil">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nechadil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/Docker cheat sheet/" class="post-title-link" itemprop="url">Docker cheat sheet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-23 22:34:40 / 修改时间：22:43:08" itemprop="dateCreated datePublished" datetime="2020-03-23T22:34:40+01:00">2020-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Docker-cheat-sheet"><a href="#Docker-cheat-sheet" class="headerlink" title="Docker cheat sheet"></a>Docker cheat sheet</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><p><code>docker ps</code> </p>
<p>获取正在运行的image列表</p>
<h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4></li>
<li><p><code>docker exec -it</code> <strong><code>container_id</code></strong> <code>bash</code></p>
<p>  开启bash交互界面</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nechadil.github.io/2018/07/13/Core-Java-Chpater-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nechadil">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nechadil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/13/Core-Java-Chpater-6/" class="post-title-link" itemprop="url">Core Java (Chpater 6)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-13 19:12:23" itemprop="dateCreated datePublished" datetime="2018-07-13T19:12:23+02:00">2018-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 22:10:27" itemprop="dateModified" datetime="2020-03-23T22:10:27+01:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter-6-Interfaces-and-Inner-Classes"><a href="#Chapter-6-Interfaces-and-Inner-Classes" class="headerlink" title="Chapter 6 Interfaces and Inner Classes"></a>Chapter 6 Interfaces and Inner Classes</h3><h4 id="6-1-Interfaces"><a href="#6-1-Interfaces" class="headerlink" title="6.1 Interfaces"></a>6.1 Interfaces</h4><ul>
<li>Accessibility<br>  all methods are <em>public</em><br>  all fields are <em>public static final</em><br>  不要写访问符</li>
<li>一个interface变量要指向一个具体的实例</li>
</ul>
<h4 id="6-2-Cloning"><a href="#6-2-Cloning" class="headerlink" title="6.2 Cloning"></a>6.2 Cloning</h4><ul>
<li>protected Object.clone( )<ul>
<li>mutable 类型克隆的结果还是指向同一对象的引用，所以需要重写。</li>
<li>因为是protected所以只能克隆自己的对象。如果属性包括其他对象则不能克隆。</li>
</ul>
</li>
<li>使用Cloneable接口进行deep clone<ul>
<li>实现clone方法，访问权限为public。</li>
<li>方法内对调用自身属性的clone方法</li>
</ul>
</li>
</ul>
<h4 id="6-3-Interfaces-and-Callbacks"><a href="#6-3-Interfaces-and-Callbacks" class="headerlink" title="6.3 Interfaces and Callbacks"></a>6.3 Interfaces and Callbacks</h4><ul>
<li>这种callback原理就是在功能类中参数是接口而不是具体实现。在实际使用时传入一个该接口的实现类。这样降低了类之间的耦合。</li>
</ul>
<h4 id="6-4-Inner-Classes"><a href="#6-4-Inner-Classes" class="headerlink" title="6.4 Inner Classes"></a>6.4 Inner Classes</h4><ul>
<li><p>为什么要用内部类？</p>
<ul>
<li>可以直接使用外部类private域<ul>
<li>可访问外部类和自身域</li>
<li>编译器自动在内部类构造方法中添加外部类引用来实现对外部类的访问</li>
</ul>
</li>
<li><p>其他类不可见</p>
<ul>
<li>只有内部类才能使用private访问符</li>
<li><p>如果内部类为public，可这样新建内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutterClass outerObject = <span class="keyword">new</span> OutterClass();</span><br><span class="line">InnerClass innerObject = outerObject.<span class="keyword">new</span> InnerClass();</span><br></pre></td></tr></table></figure>
<p>用此可见内部类的创建需要包含一个外部类的实例。</p>
</li>
</ul>
</li>
<li>匿名内部类方便定义callback</li>
</ul>
</li>
<li>编译器对内部类的实现<ul>
<li>就是简单的一个类，名为InnerClass$OuterClass</li>
<li>内部类多出一个域用来引用外部类：final OuterClass <strong>this$0</strong>；</li>
<li>内部类访问外部类域：<ul>
<li>外部类多出一个静态方法：static Type  <strong>access$0</strong>(OuterClass o);</li>
<li>访问时执行access$0(this$0);</li>
</ul>
</li>
<li>private InnerClass实现：default访问权限 + private构造方法</li>
</ul>
</li>
<li>Local Inner Class<ul>
<li>在方法内定义Class</li>
<li><strong>不带访问符!!!</strong> 方法内有效</li>
<li>优点是甚至对外部类隐藏。只有外部方法才能访问</li>
<li>可访问方法的参数，但参数在方法中必须声明final。原因：<br>  该参数会被编译器加在内部类中作为一个属性。<br>  需要保证该属性和参数在引用同样的数据，所以要定义成final，即不能被更改。</li>
<li><strong>数组被定义为final仍可以更改其中的数据</strong></li>
</ul>
</li>
<li><p>Anonymous Inner Class<br>  新建一个匿名内部类实例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个继承SuperClass类的匿名内部类。</span></span><br><span class="line"><span class="keyword">new</span> SuperClass(construction parameters) &#123;</span><br><span class="line">	inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">// 新建接口实现没有参数</span></span><br><span class="line"><span class="class"><span class="title">new</span> <span class="title">Interface</span>() </span>&#123;</span><br><span class="line">	inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">// 匿名内部类没有构造方法，如果是第一种继承父类的内部类，需使用父类的构造方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>double brace initialization<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层中括号表示匿名内部类，内层中括号是对象初始化时执行的代码块</span></span><br><span class="line">ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt; &#123;&#123;add(<span class="string">"a"</span>);add(<span class="string">"b"</span>);&#125;&#125; ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>static inner class</p>
<ul>
<li>用于不需要访问外界对象的内部类。</li>
<li>只为外部类服务（比如一个类中一个返回最大值最小值的方法，新建一个静态内部类Pair，储存最大最小值，只用于这个类，没必要在包内新建一个类）</li>
<li>接口内的内部类都是自动public static的</li>
</ul>
</li>
</ul>
<h4 id="6-5-Dynamic-Proxy"><a href="#6-5-Dynamic-Proxy" class="headerlink" title="6.5  Dynamic Proxy"></a>6.5  Dynamic Proxy</h4><p>书里讲的完全看不懂。。。但是在网上找到了<a href="http://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">这篇文章</a>，教你如何找刘德华唱歌跳舞。写得很好。</p>
<ul>
<li>总的来说分三个部分。一个是接口，比如“会表演”。一个实现类，比如“演员”。一个代理类，比如“经纪人”</li>
<li>在经纪人方法内用Proxy.getNewInstance(ClassLoader classLoader,Interface[] interfaces,InvocationHandler handler)方法获取演员的代理，方法内的interface即为实现类实现的接口。</li>
<li>InvocationHandler实例即为具体的处理者<strong>接口</strong>。实现InvocationHandler时需要重写invoke(proxy, method, args)方法。其中method即为调用的接口的某一方法。可在method.invoke()前后增加操作（如果不加method.invoke()则实现类的方法不再执行）</li>
</ul>
<blockquote>
<p>学习笔记<br>12/07/2018 (P272 ~ P299)<br>花了很多时间在单位学习，已经到了300页了。之前估计在内部类那个部分即使是汉语版也看不太懂。现在已经可以明白作者在说什么了。之后如果有相关经验再回过头来看应该会更清晰了。<br>13/07/2018（P300 ~ P314 ）<br>arrayList的初始化jeremie 之前在代码里用过，原来是这么回事啊！之前还以为是什么特殊的语法糖。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nechadil.github.io/2018/07/12/Core-Java-Chpater-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nechadil">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nechadil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/12/Core-Java-Chpater-5/" class="post-title-link" itemprop="url">Core java (Chpater 5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-12 19:11:43" itemprop="dateCreated datePublished" datetime="2018-07-12T19:11:43+02:00">2018-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 22:10:27" itemprop="dateModified" datetime="2020-03-23T22:10:27+01:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter-5-Inheritance"><a href="#Chapter-5-Inheritance" class="headerlink" title="Chapter 5 Inheritance"></a>Chapter 5 Inheritance</h3><h4 id="5-1-Class-Superclass-Subclass"><a href="#5-1-Class-Superclass-Subclass" class="headerlink" title="5.1 Class, Superclass, Subclass"></a>5.1 Class, Superclass, Subclass</h4><ul>
<li>override<ul>
<li>子类重写方法的时候对于父类私有域需要用<em>super.getter()</em>获取</li>
<li>super不是引用，而是一个引导compiler调用父类方法的关键字</li>
</ul>
</li>
<li>constructor<ul>
<li>因为子类没有访问父类属性的权限，所以必须通过父类的构造器，即super()或super(args)</li>
<li>super构造器必须是构造器的第一行（只有把父类的东西初始化了才能再初始化子类的多余部分）</li>
<li>关于super 和 this 的比较<br>Recall that the this keyword has two meanings: to denote a reference to the implicit parameter and to call another constructor of the same class. Likewise, the super keyword has two meanings: to invoke a superclass method and to invoke a superclass constructor. When used to invoke constructors, the this and super keywords are closely related. <strong>The constructor calls can only occur as the first statement in another constructor.</strong> The constructor parameters are either passed to another constructor of the same class (this) or a constructor of the superclass (super).<br>两者的作用都是1. 调用方法 2. 调用构造器</li>
</ul>
</li>
<li>polymorphism &amp; dynamic binding<br>  敲黑板了。这个第一次法国实习前公司的面试里一道我没答上的愚蠢题目。我当时还问这个词英文是什么。转眼间不到一个月实习就要结束了。<br>  <em>polymorphism: the fact that a variable can refer to multiple actual type</em><br>  <em>dynamic binding: automatically selecting the appropriate method at run time</em></li>
<li>Inheritance hierarchies</li>
<li>Inheritance hierarchies: 多个类继承同一个类</li>
<li>inheritance chain：在hierarchies中从某个类到其祖先类的路径</li>
<li><p>liskov substitution principle 里氏替换原则</p>
<ul>
<li>当需要使用父类对象的时候都可以使用子类对象<br>  比如：可以将父类对象赋值为子类对象的实例<br>  即父类可以引用（refer to）任何其子类对象。</li>
<li><p>注意下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">super[] superArray；</span><br><span class="line">superArray[0] = subObject;</span><br><span class="line">//false</span><br><span class="line">superArray[0].subMethod();</span><br><span class="line">//true</span><br><span class="line">subObject.subMethod();</span><br></pre></td></tr></table></figure>
<p>从编译器的角度考虑。数组superArray中的元素是super类，不能使用子类方法。</p>
</li>
</ul>
</li>
<li>Dynamic binding实现方式<ol>
<li>假设调用c.f(param)，编译器寻找所有c类和c的父类中符合条件的方法：<ul>
<li>可访问</li>
<li>方法名为f</li>
</ul>
</li>
<li>overloading  resolution<br>匹配参数类型（检验签名）。如果只有一个，则调用该方法</li>
<li>static binding<br>private, static, final方法编译器直接绑定（因为这三种不存在同签名方法或是与类的继承无关），不需要区分，此为静态绑定。<br>否则，调用方法由explicit parameter（即输入的参数param）的实际类型决定，在runtime时动态绑定。</li>
<li>JVM根据c的类型决定。c的类中没有则找c的父类。<br>JVM存在method table存放所有签名。每次调用类JVM去查看签名。</li>
</ol>
</li>
<li>多态好处<br>  extensible：superClass.method() 。当新加入一个superClass的子类并将superClass赋值为一个子类对象的时候，由于使用多态而不需要更改之前的代码</li>
<li>避免继承<ul>
<li>final 类：不能被继承</li>
<li>final方法：不能被override</li>
</ul>
</li>
<li><p>casting<br> 子类转父类不需要casting<br> 父类转子类则需要（因为内容增加了）<br> 可能在运行时出现ClassCastException. 因此需要<strong>instanceof</strong>判断：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Superclass super;</span><br><span class="line">if（super instanceof Subclass）</span><br><span class="line">	Subclass sub = (Subclass)super;</span><br></pre></td></tr></table></figure>
<p> null instanceof Class 总是返回false（因为null不引用任何类）</p>
</li>
<li><p>abstract class<br>当一个类需要作为其他类的基础而不需要使用它的实例的时候，使用抽象类。抽象类可以定义<strong>具体方法</strong>或者<strong>抽象方法</strong>。当没确定具体实现时使用抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">abstract class Person &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	public Person(String n) &#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract String getDescription();</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  子类实现全部抽象方法/子类没实现全部抽象方法（<strong>此时子类也必须为abstract</strong>）</p>
</li>
<li>Protected access<br>  private, public, default(package visible), protected(default + subclasses)</li>
</ul>
<h4 id="5-2-object"><a href="#5-2-object" class="headerlink" title="5.2 object"></a>5.2 object</h4><ul>
<li>every class extends object<br>only primitive types are not objects</li>
<li>equals()<ul>
<li>default: reference equals</li>
<li>implementation:<ol start="0">
<li><em>If implement equals() for subclass, test super.equals(other) first</em></li>
<li>this == otherObject ⇒ true</li>
<li>otherObject == null ⇒ false</li>
<li>getClass != otherObject.getClass() ⇒ false</li>
<li>class cast:  Class other = (Class) otherObject;</li>
<li>return a.attribute1 == other.attribute1 &amp;&amp; ……</li>
</ol>
</li>
<li>Object.equals(attribute, other.attribute) for non-primitive classes (in case attribute == null)</li>
</ul>
</li>
<li>Equality testing and Inheritance<br>  不要使用instanceof 来代替3的步骤。问题出在有subclass的时候。instanceof会通过子类（但getClass不会）。<ul>
<li>Arrays.equals(a，b) 测试数组元素是否相同</li>
<li>注意equals方法参数类型是<strong>Object</strong>!!!否则方法不是重写Object类的equals方法而是新建了另一个。</li>
</ul>
</li>
<li>hashCode()<ul>
<li>Object类hashCode()方法默认是根据对象在内存的地址</li>
<li>From java7: Objects,hashCode(object)<br>  explicit parameter 为null返回0，否则调用object的hashCode方法 </li>
<li>更简单的方法： Objects.hash(param1, param2, param3, …)生成hashCode</li>
<li>x,equals(y) ⇒ x.hashCode() == y.hashCode()</li>
<li><strong>重写hashCode方法的原因</strong>：在使用HashMap的时候，两个相同的key值应该返回相同的内容。如果不重写hashCode，Object类里的方法计算的是内存地址，一般不同。导致相同key值无法获得相同结果。</li>
<li>Arrays.hashCode（）方法返回根据数组元素hashCode生成的hashCode</li>
</ul>
</li>
<li>toString()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassA a = <span class="keyword">new</span> ClassA();</span><br><span class="line"><span class="comment">//a.toString() is called</span></span><br><span class="line">String str = <span class="string">"..."</span> + a;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-3-Generic-Array-Lists"><a href="#5-3-Generic-Array-Lists" class="headerlink" title="5.3 Generic Array Lists"></a>5.3 Generic Array Lists</h4><ul>
<li>ArrayList<employee> staff = new ArrayList&lt;&gt;();<ul>
<li><em>&lt;&gt;</em>: diamond syntax</li>
<li>ensureCapacity(100): 在达到100前不扩容（提高了效率）</li>
</ul>
</employee></li>
<li>Accessing elements<ul>
<li>array.set(i, element);   等价于 array[i] = element;<br>  set只用来修改。添加用add</li>
<li>array,get(i);</li>
</ul>
</li>
</ul>
<h4 id="5-4-Wrapper-and-Autoboxing"><a href="#5-4-Wrapper-and-Autoboxing" class="headerlink" title="5.4 Wrapper and Autoboxing"></a>5.4 Wrapper and Autoboxing</h4><ul>
<li>Wrapper<br>Interger &amp; int</li>
<li>Autoboxing (from java 5)<br>by the compiler  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	//autoBoxing</span><br><span class="line">	list.add(3); ⇐ ⇒ list.add(Integer.valueOf(3));</span><br><span class="line">	//unbox</span><br><span class="line">	int n = list.get(i) ⇐ ⇒ int n = list.get(i).intVlaue();</span><br><span class="line">	```	</span><br><span class="line"></span><br><span class="line">#### 5.5 Methods with a variable number of parameters</span><br><span class="line">* signature:</span><br><span class="line">	public void method(ClassA... params)</span><br><span class="line">* params 类型为 ClassA[ ]</span><br><span class="line"></span><br><span class="line">#### 5.6 Enumeration Classes</span><br><span class="line">	```java</span><br><span class="line">	public enum Size &#123;</span><br><span class="line">		//每个类型只有一个实例</span><br><span class="line">		Size1(attr1), Size2(attr2)...;</span><br><span class="line">		//实例的值，为私有属性</span><br><span class="line">		private AttrClass attr;</span><br><span class="line">		//实例化方法（私有方法，用于初始化）</span><br><span class="line">		private Size(AttrClass attr) &#123;this.attr = attr:&#125;</span><br><span class="line">		//公有getter</span><br><span class="line">		public AttrClass getAttr()&#123;</span><br><span class="line">				return attr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取属性值方法</span><br><span class="line">	Size.Size1.getAttr();</span><br><span class="line">	//返回Size.Size1, Size,Size2, ......</span><br><span class="line">	Size[] values = Size.values();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-7-Reflaction"><a href="#5-7-Reflaction" class="headerlink" title="5.7  Reflaction"></a>5.7  Reflaction</h4><ul>
<li><p><em>Class</em>类</p>
<ul>
<li>runtime type identification<br>  用来跟踪每个对象所属的类，JVM由此选出属于该对象的正确方法<br>  JVM针对每种类型只有一个Class对象，所以可以直接比较内存地址<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String name = object.getClass().getName();</span><br><span class="line">Class cl = Class.forName(<span class="string">"java.util.Date"</span>);</span><br><span class="line"><span class="comment">//认证类的种类</span></span><br><span class="line"><span class="keyword">if</span>(e.getClass() == AClass<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用无参构造函数创建新实例,如无此函数则抛出异常</span></span><br><span class="line">e.getClass().newInstance();</span><br><span class="line">Class.forName(<span class="string">"java.util.Date"</span>).newInstance();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类加载顺序<br>  包含main方法的class先启动，加载它需要的所有类。这些类加载它们依赖的类。</p>
<ul>
<li>Class c = object.class</li>
</ul>
</li>
<li>使用反射<ul>
<li>java,lang.reflect包：Field, Method, Constructor</li>
</ul>
</li>
<li>Generic Array</li>
<li>Invoke</li>
</ul>
<h4 id="Design-hints-for-Inheritance"><a href="#Design-hints-for-Inheritance" class="headerlink" title="Design hints for  Inheritance"></a>Design hints for  Inheritance</h4><ul>
<li></li>
</ul>
<blockquote>
<p>学习笔记<br>07/07/2018 （ P200 ~ P211）<br>周六一天只看了11页。。。至少早起了。而且在非工作日学习了。需要继续努力。好的开始。<br>08/07/2018 （ P211 ~ P221）<br>洲际赛LPL险胜，看得惊心动魄。继续努力才能安心看S8全球总决赛。你看看人家职业选手，doinb，mouse这种的，都是下放到各层联赛摸爬滚打好几个赛季才有所成，职业精神值得学习。<br>09/07/2018 (P222 - P249 )<br>11号记录。昨天晚上睡了会儿觉看了场世界杯。白天搞加密的学习也没看书。今天忽然理解坚持确实比数量要重要的多。每天10页三个月内就能搞定，20页更是一个月就完事儿了。但是如果不坚持下来很可能到最后连一本书都完成不了。不要贪快，学习乐在其中才是最重要的。每天10页书保底，一定要坚持下来。<br>12/07/2018 (P250 ~ P271)<br>用上班时间把这章最后一部分看完了。反射的部分后面有些东西就没记了。了解了一下能做什么，等到有需要的时候再回过头来学习吧。到目前为止记笔记的方式始终是边看边记。在考虑要不要做得更精致点。从下一章开始先浏览一定量的内容（比如一个小节），然后回过头来再整理。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nechadil.github.io/2018/07/06/Core Java (Chapter 4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nechadil">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nechadil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/06/Core Java (Chapter 4)/" class="post-title-link" itemprop="url">Core Java (Chapter 4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-06 18:17:37" itemprop="dateCreated datePublished" datetime="2018-07-06T18:17:37+02:00">2018-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 22:10:27" itemprop="dateModified" datetime="2020-03-23T22:10:27+01:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter-4-Objects-and-Classes"><a href="#Chapter-4-Objects-and-Classes" class="headerlink" title="Chapter 4 Objects and Classes"></a>Chapter 4 Objects and Classes</h3><h4 id="4-1-Intro"><a href="#4-1-Intro" class="headerlink" title="4.1 Intro"></a>4.1 Intro</h4><ul>
<li>programming paradigm: oop vs structured procedural programming<ul>
<li>structured: algo + data structures</li>
<li>oop: data structures + algo</li>
</ul>
</li>
<li>Big problems:<ul>
<li>2000 procedures + global data</li>
<li>100 classes * 20 methods + Object data</li>
</ul>
</li>
<li>Encapsulation:<ul>
<li>combine data + behavior in one package</li>
<li>hide implementation details from user of the object</li>
<li>access instance fields by methods</li>
</ul>
</li>
<li>Relations between classes<ul>
<li>Dependence (use - a): minimize the coupling</li>
<li>Aggregation (has - a)</li>
<li>Inheritance (is - a)</li>
</ul>
</li>
</ul>
<h4 id="4-2-Using-predefined-classes"><a href="#4-2-Using-predefined-classes" class="headerlink" title="4.2 Using predefined classes"></a>4.2 Using predefined classes</h4><ul>
<li>Object variable <strong>refers</strong> to an object (not <em>contains</em>)</li>
<li>Date: a point in time<br>  GregorianCalendar: dates in the gregorian calendar notation</li>
<li>mutator methods: change instance fields (setter, …)<br>  accessor methods: only accesss instance fields (getter)</li>
</ul>
<h4 id="4-3-Define-a-Class"><a href="#4-3-Define-a-Class" class="headerlink" title="4.3 Define a Class"></a>4.3 Define a Class</h4><ul>
<li>implicit param: object before the method (<em>this</em>)<br>  explicit param: params in the signature of method</li>
<li><p>getter &amp; setter vs. public attribut:</p>
<ul>
<li><p>change the internal implementation whithoud affecting any code other than the methods</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old version</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//New version</span></span><br><span class="line"><span class="keyword">private</span> String firstName;</span><br><span class="line"><span class="keyword">private</span> String lastName;</span><br><span class="line"><span class="comment">//without getter: change everywhere that used aObject.name</span></span><br><span class="line">aObject.name ⇒ aObject.firstName + AObject.lastName;</span><br><span class="line"><span class="comment">//with getter: only need to change the getter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>do the error check or convert inside the getter/setter</p>
</li>
</ul>
</li>
<li><p><strong>Do not</strong> return a mutable object</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"><span class="comment">//return a Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//date attribut can be modified, so breaks encapsulation!!</span></span><br><span class="line">d = aObject.getDate();</span><br><span class="line">d.setTime(blabla);</span><br><span class="line"><span class="comment">//do this way:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> date.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>a method of a class is permitted to access the private fields of any object of this class</strong></p>
</li>
<li>final<ul>
<li>must be initialized when the object is constructed (in constructure or declairation)</li>
<li>final + primitive type /immutable class</li>
<li>final method/attribut : can’t be overwrite/modified</li>
</ul>
</li>
</ul>
<h4 id="4-4-static-fields-and-methods"><a href="#4-4-static-fields-and-methods" class="headerlink" title="4.4 static fields and methods"></a>4.4 static fields and methods</h4><ul>
<li>static<ul>
<li>belongs to class not object</li>
<li>only one copy for 0 to any number of objects</li>
</ul>
</li>
<li>static constants<ul>
<li>static final </li>
</ul>
</li>
<li>static method<ul>
<li>no implicit param</li>
<li>has access to static field of the same class</li>
</ul>
</li>
<li>Factory method<ul>
<li>static method</li>
<li>creates various objects from a same class</li>
</ul>
</li>
</ul>
<h4 id="4-5-method-parameters"><a href="#4-5-method-parameters" class="headerlink" title="4.5  method parameters"></a>4.5  method parameters</h4><ul>
<li>call by value: just get the value passed<br>  call by reference: method gets the <em>location</em> of the     variable the caller provides<ul>
<li>java <strong>always</strong> uses call by value </li>
<li><em>object references are passed by value</em>（swap方法不起作用）</li>
<li><strong>A method cannot modify a parameter of a primitive type (that is, numbers or boolean values).</strong></li>
<li><strong>A method can change the state of an object parameter.</strong></li>
<li><strong>A method cannot make an object parameter refer to a new object.</strong></li>
<li>最后说一句，就是Java是值传递，但是对于对象类型传递的值是一个引用。所以调用引用对象的方法是可以改变对象state的，但是没法改变引用的对象，因为传的是值，并不是引用。</li>
</ul>
</li>
</ul>
<h4 id="4-6-Object-construction"><a href="#4-6-Object-construction" class="headerlink" title="4.6 Object construction"></a>4.6 Object construction</h4><ul>
<li>overloading: sevral methods have the same name but different parameters.</li>
<li>Constructor with no arguments: <ul>
<li>a free no-argument constructor only when your class has no other constructors  (otherwise create it if needed)</li>
</ul>
</li>
<li><p>calling another constructure with <em>this</em></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// calls Employee(String, double)</span></span><br><span class="line">	<span class="keyword">this</span>(<span class="string">"Employee #"</span> + nextId, s);</span><br><span class="line">	nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Initialization Blocks</strong></p>
<ul>
<li><strong>Class declarations can contain arbitrary blocks of code. These blocks are executed whenever an object of that class is constructed.</strong></li>
<li>The initialization block runs first, and then the body of the constructor is executed.</li>
<li><ol>
<li>All data fields are initialized to their default values (0, false, or null).<ol start="2">
<li>All field initializers(在属性声明时初始化) and initialization blocks are executed, in the order in which they occur in the class declaration.</li>
<li>If the first line of the constructor calls a second constructor, then the body of the second constructor is executed.</li>
<li>The body of the constructor is executed.</li>
</ol>
</li>
</ol>
</li>
<li><p>static block</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//executed when the class is first loaded</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="comment">//initialize static fields here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>All static field initializers and static initialization blocks are executed in the order in which they occur in the class declaration. （注意这个是类加载时执行，所以比类的对象生成的时间要早）</p>
</li>
<li>Destruction and <em>finalize</em></li>
<li><em>finalize</em> method<ul>
<li>finalize() may be invoked on an object when it becomes garbage. Object’s implementation of finalize() does nothing—you can override finalize() to do cleanup, such as freeing resources.</li>
<li>The finalize() method may be called automatically by the system, but when it is called, or even if it is called, is uncertain. Therefore, you should not rely on this method to do your cleanup for you. For example, if you don’t close file descriptors in your code after performing I/O and you expect finalize() to close them for you, you may run out of file descriptors.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-7-Packages"><a href="#4-7-Packages" class="headerlink" title="4.7 Packages"></a>4.7 Packages</h4><ul>
<li>reason: garantee the uniqueness of class names</li>
<li><strong>compiler locates classes in package</strong>: bytecodes in class file classes are referred in full package</li>
<li><p>import static</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//importing not just classes but also static methods/fileds</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line">out.println(<span class="string">"Goodbye, World!"</span>); <span class="comment">// i.e., System.out</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>compile .java file of class in package a.b.c ⇒ .class file in subdirectory a/b/c</p>
</li>
<li>Package scope(范围)<ul>
<li>private public</li>
<li>default: accessible in the same package</li>
</ul>
</li>
</ul>
<h4 id="4-8-Class-path"><a href="#4-8-Class-path" class="headerlink" title="4.8 Class path"></a>4.8 Class path</h4><ul>
<li><p>use .jar file</p>
<ul>
<li><p>set <strong>class path</strong></p>
<ol>
<li>class path is the collection of all locations that can contain class files<br> 格式：地址a:(windows中是;)地址b:地址c<br> 此处地址可以是文件路径（如：/home/user/classdir或<strong>.</strong>代表当前文件夹）<br> 也可以是jar包路径（如；/home/user/archives/archive.jar）</li>
<li>Java 6开始支持通配符，如<em>home/user/archives/‘\</em>‘*代表archives下所有<strong>jar包</strong>（而不是class文件）</li>
<li>runtime libraray files(jre/lib 和 jre/lib/ext)不需要导入</li>
<li>compiler： 始终会在当前文件夹寻找<br> JVM：只有<em>.</em>在classpath时才会在当前文件夹寻找类。class path默认含当前文件夹（即不设置的时候）。如果设置了而不含当前文件夹，则编译通过但运行不一定通过。</li>
<li>JVM寻找类的过程：<ul>
<li>条件： class path = /home/user/classdir:.:/home/user/archives/archive.jar<pre><code>要找的类：com.horstmann.corejava.Employee
</code></pre></li>
<li>在jre/lib 和 jre/lib/ext中找</li>
<li>找/home/user/classdir/com/horstmann/corejava/Employee.class</li>
<li>在当前文件夹找 com/horstmann/corejava/Employee.class</li>
<li>在archiver.jar中找 com/horstmann/corejava/Employee.class</li>
</ul>
</li>
<li><p>compiler确定类全名的过程（注意JVM读取class文件。而class文件里类都是全名，所以不存在这一过程。只有compiler在将java文件转化成class文件时才需要定位引用文件的位置）：</p>
<ul>
<li>如果类包含package全名： 结束</li>
<li><p>否则按下列方式执行。条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.\*;</span><br><span class="line"><span class="keyword">import</span> com.horstmann.corejava.\*;	</span><br><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br></pre></td></tr></table></figure>
</li>
<li><p>先找java.lang.Employee (因为java.lang包总是默认导入)</p>
</li>
<li>再找java.util.Employee</li>
<li>com.horstmann.corejava.Employee</li>
<li>在当前包中找Employee</li>
<li><em>找到多个相同类报compile error</em></li>
<li><em>compiler比对源代码和class文件的版本。如class文件版本落后则更新</em></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="4-9-comments"><a href="#4-9-comments" class="headerlink" title="4.9 comments"></a>4.9 comments</h4><pre><code>(maybe) see later
</code></pre><h4 id="4-10-Class-design-hints"><a href="#4-10-Class-design-hints" class="headerlink" title="4.10 Class design hints"></a>4.10 Class design hints</h4><blockquote>
<h4 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h4><h5 id="05-07-2018"><a href="#05-07-2018" class="headerlink" title="05/07/2018"></a>05/07/2018</h5><p>P134 - P182<br>按这个进度大概九月份才能读完（还是在每天学习的情况下）。恩，现在不是讨论早晚的问题，而是先坚持下去。在上班没其他事情的情况下进度也不是很快，主要是有些地方还是挺需要动脑的。今天这一部分最主要的是类加载机制和Java的值传递。</p>
<h5 id="06-07-2018"><a href="#06-07-2018" class="headerlink" title="06/07/2018"></a>06/07/2018</h5><p>P183 - P199<br>干货比较多。比如package，classpath。注意compiler，JVM对于类加载的机制。<br>还有就是今天才发现外部类只有public和default两种。为什么没有private？因为private类无法被外部访问，没意义。为什么没有protected？因为protected只能被同包或子类访问。前者即是default，后者就意味着一个问题，如何控制该包能被什么类继承？如果所有类都能继承，即所有类都是子类，即所有类都能访问该类，那该类就是public。如果没有类可以继承，那该类就是default。如果只有部分类可以继承。那是哪一部分呢？无法指定。所以类的访问权限（而不是方法）最小就是同包。<br>还有就是一个Java文件只允许一个public类，同时文件名必须与类名相同。没在网上确认，我的理解是这在import的时候很有用，同时涉及JVM加载类机制。如果一个包使用另一个类，JVM就要去class path里通过文件系统找这个类。如果类名和文件名不同这个过程就会很复杂。<br>第四章终于在班上结束了。之后回家要开始第五章的学习了。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nechadil.github.io/2018/07/05/Core Java (Chapter 3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nechadil">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nechadil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/05/Core Java (Chapter 3)/" class="post-title-link" itemprop="url">Core Java (Chapter 3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 19:37:40" itemprop="dateCreated datePublished" datetime="2018-07-05T19:37:40+02:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 22:10:27" itemprop="dateModified" datetime="2020-03-23T22:10:27+01:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很惭愧地上网下了一个英文版pdf。想想两三年前就买了这本书的中文版，就又有些许的心安理得。重新看一遍吧。之前看了好几回都没能通过第四章的样子。如今两年过去做了些项目，应该会容易些。争取在年末前先过一遍。<br>前两章略过了，直接从基础概念看起。</p>
<h3 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h3><h4 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h4><ul>
<li>整形（byte，short，int，long）：存储空间，范围</li>
<li>浮点（float，double）：单双精度。使用BigDecimal类进行精确计算。</li>
<li>字符(char)：2bytes<br>今天下午正好也在研究字符的东西。Java里的char是表示UTF-16 encoding下的code units。比如: System.out.println(“\uD835\uDD6B”)的结果是zz。注意一个code point是指在Unicode的code page中字符与代码的映射。在不同的caracter encoding下（UTF-8，UTF-16）一个code point对应不同数量的code unit。</li>
</ul>
<h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h4><ul>
<li>final 不可变量<br>使用static final在类中声明供所有内部方法使用。</li>
</ul>
<h4 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3. 类型转换"></a>3. 类型转换</h4><p>原则是不丢失信息。比如byte =&gt; short =&gt; int =&gt;long  </p>
<h4 id="4-enumerated-type"><a href="#4-enumerated-type" class="headerlink" title="4. enumerated type"></a>4. enumerated type</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE &#125;</span><br><span class="line">Size s = Size.MEDIUM;</span><br></pre></td></tr></table></figure>
<h4 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h4><ul>
<li><p>substring </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">"Hello"</span>;</span><br><span class="line">String s = greeting.substring(<span class="number">0</span>, <span class="number">3</span>);<span class="comment">//'Hel'(0~2)</span></span><br></pre></td></tr></table></figure>
<p>  这种方式优点是两个参数相减长度即为字符串长</p>
</li>
<li>immutable<br>关于动机几乎类似月经贴了，总是记不住。<br>首先字符串的改变本质是引用对象的改变。改变后之前字符串的<strong>值</strong>是不可变的。<br>为什么这样做？一方面这种方式不能直接修改字符，降低了效率。另一方面使字符串保存在常量池里，可以被共享，提高了效率。</li>
<li><p>Code point &amp; Code unit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">"𝕫"</span>.charAt(<span class="number">1</span>)；<span class="comment">//返回的是这个Unicode code point在UTF-16下的第二个code unit值</span></span><br></pre></td></tr></table></figure>
<p>所以使用char是很危险的，因为supplementary characters是用一对儿code unit来表示而不是一个。而一个char表示一个code unit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历字符串</span></span><br><span class="line"><span class="keyword">int</span> cp = sentence.codePointAt(i);</span><br><span class="line"><span class="comment">//Characters whose code points are greater than U+FFFF are called supplementary characters.</span></span><br><span class="line"><span class="keyword">if</span> (Character.isSupplementaryCodePoint(cp)) i += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历字符串</span></span><br><span class="line">i--;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Determines if the given `char` value is a Unicode surrogate code unit.</span></span><br><span class="line"><span class="comment">Such values do not represent characters by themselves, but are used in the representation of [supplementary characters](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#supplementary) in the UTF-16 encoding.</span></span><br><span class="line"><span class="comment">A char value is a surrogate code unit if and only if it is either a low-surrogate code unit or a high-surrogate code unit.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">if</span> (Character.isSurrogate(sentence.charAt(i))) i--;</span><br><span class="line"><span class="keyword">int</span> cp = sentence.codePointAt(i);</span><br></pre></td></tr></table></figure>
<p>  注意两种遍历一种是以code point为单位，一种是以code unit为单位。</p>
</li>
<li><p>字符串的连接<br>（原来从开头就出现了面试基础知识。看来不是面试题难，而是书看的确实不够。真的都是最基础的点了。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好处是避免了多个String对象的创建</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(ch); <span class="comment">// appends a single character</span></span><br><span class="line">builder.append(str); <span class="comment">// appends a string</span></span><br><span class="line">String completedString = builder.toString()；</span><br></pre></td></tr></table></figure>
<p>  这里还有一个月经问题就是StringBuffer和StringBuilder的区别。StringBuffer是线程安全的，实现原理是在某些方法上加了synchronize关键字。但是StringBuffer好像没什么人用了，因为线程安全对于字符串而言好像没什么意义。</p>
</li>
</ul>
<h4 id="6-输入输出"><a href="#6-输入输出" class="headerlink" title="6. 输入输出"></a>6. 输入输出</h4><ul>
<li>输入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//console</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String aLine = in.nextLine();</span><br><span class="line">String aWord = in.next();</span><br><span class="line"><span class="keyword">int</span> aInt = in.nextInt();</span><br><span class="line"><span class="comment">//fileIO</span></span><br><span class="line">Scanner fileInput = <span class="function">nez <span class="title">Scanner</span><span class="params">(Path.get(<span class="string">"x.txt"</span>)</span>)</span>;</span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"output.txt"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-control-flow"><a href="#7-control-flow" class="headerlink" title="7. control flow"></a>7. control flow</h4><ul>
<li>do while</li>
<li><p>switch</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="keyword">var</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> var1:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> var2:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  注意没有break则会继续进行判断。作者评价如下：</p>
<blockquote>
<p>This behavior is<br>plainly dangerous and a common cause for errors. For that reason, we never use the switch<br>statement in our programs.</p>
</blockquote>
</li>
<li><p>break control flow</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break out of loop</span></span><br><span class="line"><span class="keyword">while</span>(tset)&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break out of multiple nested loop</span></span><br><span class="line"><span class="comment">// label + colon</span></span><br><span class="line">break_label:</span><br><span class="line"><span class="keyword">while</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span>()&#123;</span><br><span class="line">			<span class="comment">// out of all the loops</span></span><br><span class="line">			<span class="keyword">break</span> break_label;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jumps here</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>array</p>
<ul>
<li><p>copy array</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrayA = arrayB;</span><br><span class="line"><span class="comment">//modified  also the arrayB</span></span><br><span class="line">arrayA[<span class="number">3</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>注意Java是传递引用。所以如果想新建数组使用Arrays.copyOf(arrayB, arrayB.length)方法。</p>
</li>
<li>扩容<pre><code class="Java">Arrays.copyOf(arrayB, arrayB.length*<span class="number">2</span>);
</code></pre>
</li>
<li>彩票抽奖<br>程序就不贴了。这里边的问题是如何从一个数组中取出几个不重复的随机数。要点是每次随机的数不是值而是index。这样当这个index里的值被保存后把最后一个值传到index里，同时把取值范围减一。这样最后一位就不会被计入下次抽取中，同时把上一个抽取到的值从数组中抹去。</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h3><h4 id="2018-06-28（P59-P90）"><a href="#2018-06-28（P59-P90）" class="headerlink" title="2018/06/28（P59~P90）"></a>2018/06/28（P59~P90）</h4><p>真的是常看常新。三年前快冬天的时候我还记得看这一章觉得很简单，其实里边内容很多。要见识的多了再回头看才能有更多收获。</p>
<h4 id="2018-07-02-P91-P112"><a href="#2018-07-02-P91-P112" class="headerlink" title="2018/07/02 (P91-P112)"></a>2018/07/02 (P91-P112)</h4><p>进度差了一些。</p>
<h4 id="2018-07-03-P113-P134"><a href="#2018-07-03-P113-P134" class="headerlink" title="2018/07/03(P113-P134)"></a>2018/07/03(P113-P134)</h4><p>这个是4号记的笔记了。总体来说进度感觉有点慢。尝试要不要简略地过一遍然后把一个脉络记下来。但是总算完成了一章的学习。继续努力。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nechadil.github.io/2018/06/28/第一阶段的学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nechadil">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nechadil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/28/第一阶段的学习/" class="post-title-link" itemprop="url">第一阶段的学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-28 19:00:22" itemprop="dateCreated datePublished" datetime="2018-06-28T19:00:22+02:00">2018-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 22:10:27" itemprop="dateModified" datetime="2020-03-23T22:10:27+01:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>按照陈皓大神的观点，深入理解Java大概要掌握这些知识点。<br>从今天开个头。争取能在三年内先通读一遍并记录笔记。本来想的是两年内。想想又改成了三年。其实这么大岁数了，也没必要较真两年还是三年了。早就明白一个道理，只有坚持了下来和没有坚持下来的区别。<strong>所有的慢都不是失败，放弃才是</strong>。</p>
<p>入门：</p>
<ul>
<li>Core Java</li>
<li>Head First设计模式</li>
<li>Spring实战</li>
</ul>
<p>进阶： </p>
<ul>
<li>Effective Java</li>
<li>Java并发编程实战</li>
<li>Java性能权威指南</li>
<li>深入理解Java虚拟机</li>
<li>精通Spring4.x</li>
<li>设计模式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nechadil.github.io/2018/06/26/一次艰难的创站经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nechadil">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nechadil">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/26/一次艰难的创站经历/" class="post-title-link" itemprop="url">一次艰难的创站经历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-26 23:44:02" itemprop="dateCreated datePublished" datetime="2018-06-26T23:44:02+02:00">2018-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 22:10:27" itemprop="dateModified" datetime="2020-03-23T22:10:27+01:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>终于把主题安装好了。整个建站过程耗时两晚，然而<strong>真正</strong>有价值的时间大概只有不到一个小时。本来的目的是开始记录自己学习编程的过程，结果创建博客就折腾了这么久，有点哭笑不得。</p>
<p>讲道理来说如今科技进步这么快理应出现各种傻瓜包，一个按键就解决所有问题。看来这种建站工具还是没能强大到这一点。从另一方面说明我对前端的构建工具一点也不熟悉。想想如果是导入个jar包或者import一个项目的话，即便没用过也不至于花这么久时间才完成目的。</p>
<p>一个比较有趣的事情是我没有选择github推荐的Jekyll（直到现在我也没弄明白这个词该怎么读）。由于官方不推荐在windows下安装，于是我在虚拟机上鼓捣了半天。先是用之前装的CentOS。结果花了好久的时间配置之后响应速度还是令人窒息。于是我又重新打开了Ubuntu。Ubuntu的桌面上还留着我16年写的C程序。而且因为是在挂起状态所以启动的瞬间让我也是有点恍惚，像是忽然回到了两年前的时光，时间一下在那个时刻定格了一样。所以计算机这个东西还是有点邪门的，这种印象可不是看看过去读过的书就能体会到的。总之唏嘘完之后我发现原因就是电脑的问题而不是虚拟机的问题。在浏览器和shell间切换的时候我感觉自己仿佛回到了1998年，那个时候什么都慢。网速低得能让你在图片加载的过程中身体由软变硬，再由硬变软。。。也不知道硬件升级都升级到哪了，资源全被傻逼windows给吃了。是时候把购买Mac提上日程了。我还是忘不了当年从南大退学回寝室的时候，看我之前的室友买了个Mac结果装了个windows系统。。。</p>
<p>好像有点跑题了。正经的事就是我运行shell的时候发现（其实是后来才发现）我的系统版本太低了，用<code>apt-get install</code>命令的时候系统提示有些文件无法验证，选择继续之后就是有些文件无法获取。这个时候我犯了一个过去就经常犯的错误，<strong>在发现解决方案看似有些复杂的时候轻易就想着逃避到另一种方案</strong>。网上给出的解决办法是手动吧apt的软件获取地址改成<em>oldrelease</em>开头的一个地址。最后证明得益于Linux命令行的强大，加起来一共不到六步操作。但是不懂linux的结果就是要手动改每一个地址。想想就头大。于是我想着能不能手动下载然后用makefile安装。结果Ruby安装过程还算顺利，虽然也是一堆warning，但总算给安装完了。Rubygem也是以次方式安装的。结果最后一步安装Jekyll的时候提示说少一个z**lib的压缩库？于是心态彻底爆炸，去吃了两包炸酱面。。。结果就是该走的坑终归要走。硬着头皮查了怎么解决旧版本url地址的问题，结果打了几行命令就搞定了。虽然最后还是没能解决安装Jekyll的问题，但是至少到那一步问题就不是之前那么简单了。github上有个人评论出这种问题是因为Ruby屎一样的依赖引用，所以即便只用一个版本也最好用Ruby的版本管理器来安装Ruby。我想想还是算了，第一次和Ruby的接触即便没什么大收获也算是窥见到这类脚本语言的尿性了，于是去查了下Hexo和Jekyll的对比。发现Hexo没有Jekyll那么多的依赖包，同时在windows下运行没有问题。这里要提一句就是我之前复制粘贴异常信息的时候如果搜中文经常能搜到分析了半天加上连篇的截屏结果最后结论是网络连接问题。。。卧槽。我当时的想法是想骂他一顿，当然是心里默骂。但是转念一想，自己也开始写博客了。究竟是该接着骂然后自己把博客写的更精致些呢还是屏蔽掉搜索引擎然后接着骂呢？还是说，从逻辑的角度，如果不能证明人家写这个东西就是为了让别人搜索到的，就没办法骂他，甚至也不该生气或者觉得这个人愚蠢。但是这么一本正经分析和记录解决方案到网上结果结论是网络连接故障。。。。。。我觉得还是no comment的态度好一点。其实大多数情况下我还是这些博客狂的受益者，虽然要花大量的时间筛选掉垃圾信息。国外的网站如果想来救急就相对没那么容易。除非问答网站正好问到自己心里去了。好像很少有人写垃圾博客的样子。这一点值得思考。我还是找时间看看怎么屏蔽搜索引擎好了。虽然这种脚本生成的网站不知道能不能像普通网站一样实现。</p>
<p>恩，总之一步步照着一个博客用Hexo实现了个人主页，在这两个晚上的最后一个小时之内。虽然中途碰到了久违的SSH认证的问题和因为漏掉一步操作污心烦躁于是删了项目重建耽误了一小点时间，总之事情是顺利解决了。其实仔细想想最重要的还真的是基础知识和知识面的问题，否则即便是从来没接触过的东西只要有相关经验还是很好想通的，比如linux，git，脚本语言这些东西，接触过之后大致也能明白安装的流程大概都是什么意思，这样碰到问题也知道该从哪下手。毕竟软件安装不像是家电安装，异常的情况还是挺容易出现的。所以从这个经历来看，到底是linux的用户体验好还是windows的用户体验好呢？我思考了十秒钟的结论是Java的用户体验还是很不错的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Nechadil</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nechadil</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
